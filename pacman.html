<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <title>Pac-Man com IA Avançada</title>
    <style>
        body {
            background: linear-gradient(135deg, #0a0a1a, #1a1a3a);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            color: #ffffff;
        }
        #game {
            position: relative;
            width: 560px;
            height: 620px;
            background: #111136;
            border: 4px solid #00E5FF;
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.5);
            background-image: linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                            linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        canvas {
            display: block;
            background: #111136;
            position: relative;
            z-index: 1;
        }
        #scoreboard {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            text-align: center;
            font-size: 24px;
            color: #00E5FF;
            text-shadow: 0 0 10px #00E5FF, 0 0 20px #00E5FF;
            background: rgba(17, 17, 54, 0.8);
            padding: 10px 0;
            border-radius: 5px;
            border: 2px solid #00E5FF;
            transition: border-color 0.5s ease;
            z-index: 2;
        }
        #scoreboard:hover {
            border-color: #FFEB3B;
        }
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
            animation: fadeDarken 1s ease-in forwards;
        }
        #gameOverContent {
            background: linear-gradient(135deg, #1a1a3a, #2a2a5a);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.7);
            border: 3px solid #00E5FF;
            animation: slideIn 0.5s ease-in 1s forwards;
            opacity: 0;
        }
        #gameOverContent h1 {
            font-size: 60px;
            color: #ff0055;
            margin: 0;
            text-transform: uppercase;
            text-shadow: 0 0 15px #ff0055, 0 0 30px #ff0055;
            animation: glitch 1.5s infinite;
            position: relative;
        }
        #gameOverContent h1::before,
        #gameOverContent h1::after {
            content: "Game Over";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: #ff0055;
            opacity: 0.5;
        }
        #gameOverContent h1::before {
            animation: glitchTop 1s infinite;
            transform: translate(-2px, -2px);
        }
        #gameOverContent h1::after {
            animation: glitchBottom 1.5s infinite;
            transform: translate(2px, 2px);
        }
        #gameOverContent p {
            font-size: 28px;
            color: #ffffff;
            margin: 15px 0 25px;
            text-shadow: 0 0 5px #ffffff;
        }
        #restartButton {
            font-size: 20px;
            color: #00E5FF;
            background: linear-gradient(145deg, #1a1a3a, #2a2a5a);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid #00E5FF;
            box-shadow: 0 5px 15px rgba(0, 229, 255, 0.4), inset 0 2px 5px rgba(255, 235, 59, 0.2);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        #restartButton:hover {
            background: linear-gradient(145deg, #2a2a5a, #3a3a7a);
            box-shadow: 0 8px 20px rgba(0, 229, 255, 0.6), inset 0 2px 5px rgba(255, 235, 59, 0.4);
            transform: translateY(-2px);
        }
        #restartButton:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 229, 255, 0.3);
        }
        #restartButton::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 235, 59, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        #restartButton:hover::after {
            width: 200px;
            height: 200px;
        }
        @keyframes fadeDarken {
            0% { background: rgba(0, 0, 0, 0); }
            100% { background: rgba(0, 0, 0, 0.8); }
        }
        @keyframes slideIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes glitch {
            0% { text-shadow: 0 0 15px #ff0055, 0 0 30px #ff0055; }
            20% { text-shadow: 2px 2px 15px #ff0055, -2px -2px 30px #00E5FF; }
            40% { text-shadow: -2px 2px 15px #ff0055, 2px -2px 30px #00E5FF; }
            60% { text-shadow: 2px -2px 15px #ff0055, -2px 2px 30px #00E5FF; }
            80% { text-shadow: -2px -2px 15px #ff0055, 2px 2px 30px #00E5FF; }
            100% { text-shadow: 0 0 15px #ff0055, 0 0 30px #ff0055; }
        }
        @keyframes glitchTop {
            0% { clip-path: polygon(0 0, 100% 0, 100% 33%, 0 33%); }
            20% { clip-path: polygon(0 10%, 100% 10%, 100% 43%, 0 43%); }
            40% { clip-path: polygon(0 20%, 100% 20%, 100% 53%, 0 53%); }
            60% { clip-path: polygon(0 30%, 100% 30%, 100% 63%, 0 63%); }
            80% { clip-path: polygon(0 40%, 100% 40%, 100% 73%, 0 73%); }
            100% { clip-path: polygon(0 0, 100% 0, 100% 33%, 0 33%); }
        }
        @keyframes glitchBottom {
            0% { clip-path: polygon(0 67%, 100% 67%, 100% 100%, 0 100%); }
            20% { clip-path: polygon(0 57%, 100% 57%, 100% 90%, 0 90%); }
            40% { clip-path: polygon(0 47%, 100% 47%, 100% 80%, 0 80%); }
            60% { clip-path: polygon(0 37%, 100% 37%, 100% 70%, 0 70%); }
            80% { clip-path: polygon(0 27%, 100% 27%, 100% 60%, 0 60%); }
            100% { clip-path: polygon(0 67%, 100% 67%, 100% 100%, 0 100%); }
        }
    </style>
</head>
<body>
    <div id="game">
        <div id="scoreboard">Pontos: 0</div>
        <canvas id="canvas" width="560" height="620"></canvas>
        <div id="gameOver">
            <div id="gameOverContent">
                <h1>Game Over</h1>
                <p>Sua pontuação: <span id="finalScore">0</span></p>
                <div id="restartButton">Reiniciar</div>
            </div>
        </div>
    </div>

<script>
(() => {
  const mapData = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#G####.#####.##.#####.####G#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.##### ## #####.######",
    "     #.##### ## #####.#     ",
    "     #.##          ##.#     ",
    "     #.## ###--### ##.#     ",
    "######.## #      # ##.######",
    "      .   #      #   .      ",
    "######.## #      # ##.######",
    "     #.## ######## ##.#     ",
    "     #.##          ##.#     ",
    "     #.## ######## ##.#     ",
    "######.## ######## ##.######",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#G..##................##..G#",
    "###.##.##.########.##.##.###",
    "#......##....##....##......#",
    "#.##########.##.##########.#",
    "#.##########.##.##########.#",
    "#..........................#",
    "############################"
  ];

    const rows = mapData.length;
    const cols = mapData[0].length;
    const tileSize = 20;

    let score = 0;
    let gameOver = false;
    let deathAnimation = false;
    let deathProgress = 0;

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const scoreboard = document.getElementById("scoreboard");
    const gameOverDiv = document.getElementById("gameOver");
    const finalScore = document.getElementById("finalScore");
    const restartButton = document.getElementById("restartButton");

    const map = mapData.map(row => row.split(''));

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(freq, duration = 100) {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.frequency.value = freq;
        oscillator.type = 'square';
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + duration / 1000);
    }

    const particles = [];
    class Particle {
        constructor(x, y, vx, vy, color) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.color = color;
            this.life = 30;
            this.size = Math.random() * 3 + 2;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            this.size *= 0.95;
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function spawnParticles(x, y, count, color = '#FFEB3B') {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 2 + 1;
            particles.push(new Particle(
                x * tileSize + tileSize / 2,
                y * tileSize + tileSize / 2,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed,
                color
            ));
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    function drawParticles() {
        particles.forEach(p => p.draw());
    }

    function drawMap() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const tile = map[y][x];
                const px = x * tileSize;
                const py = y * tileSize;
                if (tile === '#') {
                    ctx.fillStyle = '#00E5FF';
                    ctx.fillRect(px, py, tileSize, tileSize);
                    ctx.strokeStyle = 'rgba(0, 229, 255, 0.3)';
                    ctx.strokeRect(px, py, tileSize, tileSize);
                } else if (tile === '.') {
                    ctx.fillStyle = '#FFEB3B';
                    ctx.beginPath();
                    ctx.arc(px + tileSize / 2, py + tileSize / 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (tile === 'G') {
                    ctx.fillStyle = '#ff0055';
                    ctx.beginPath();
                    ctx.arc(px + tileSize / 2, py + tileSize / 2, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
    }

    const pacman = {
        x: 13,
        y: 23,
        dx: 0,
        dy: 0,
        nextDx: 0,
        nextDy: 0,
        radius: tileSize / 2 - 2,
        mouthOpen: 0,
        mouthDir: 1
    };

    class Ghost {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.moveCooldown = 0;
            this.frightened = false;
            this.frightenedCounter = 0;
        }

        draw() {
            const px = this.x * tileSize + tileSize / 2;
            const py = this.y * tileSize + tileSize / 2;
            ctx.fillStyle = this.frightened ? '#00E5FF' : this.color;
            ctx.beginPath();
            ctx.arc(px, py, tileSize / 2 - 2, Math.PI, 0);
            ctx.lineTo(px + tileSize / 2 - 2, py + tileSize / 2 - 2);
            ctx.lineTo(px - tileSize / 2 + 2, py + tileSize / 2 - 2);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(px - 5, py - 3, 5, 7, 0, 0, 2 * Math.PI);
            ctx.ellipse(px + 5, py - 3, 5, 7, 0, 0, 2 * Math.PI);
            ctx.fill();

            const offsetX = Math.sign(pacman.x - this.x) * 2;
            const offsetY = Math.sign(pacman.y - this.y) * 2;
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.ellipse(px - 5 + offsetX, py - 3 + offsetY, 2, 3, 0, 0, 2 * Math.PI);
            ctx.ellipse(px + 5 + offsetX, py - 3 + offsetY, 2, 3, 0, 0, 2 * Math.PI);
            ctx.fill();
        }

        move() {
            if (this.moveCooldown > 0) {
                this.moveCooldown--;
                return;
            }
            if (this.frightened) {
                const directions = [
                    { dx: 1, dy: 0 },
                    { dx: -1, dy: 0 },
                    { dx: 0, dy: 1 },
                    { dx: 0, dy: -1 }
                ];
                let possibles = directions.filter(d => canMove(this.x + d.dx, this.y + d.dy));
                if (possibles.length === 0) return;
                let move = possibles[Math.floor(Math.random() * possibles.length)];
                this.x += move.dx;
                this.y += move.dy;
            } else {
                const path = bfs(this.x, this.y, pacman.x, pacman.y, map);
                if (path && path.length > 1) {
                    const nextStep = path[1];
                    this.x = nextStep.x;
                    this.y = nextStep.y;
                }
            }
            this.moveCooldown = 10;
            if (this.frightened) {
                this.frightenedCounter--;
                if (this.frightenedCounter <= 0) {
                    this.frightened = false;
                }
            }
        }
    }

    const ghosts = [
        new Ghost(13, 11, '#ff0055'),
        new Ghost(14, 11, '#00E5FF'),
        new Ghost(12, 11, '#FFEB3B'),
        new Ghost(15, 11, '#ff00ff')
    ];

    function bfs(startX, startY, targetX, targetY, map) {
        const queue = [];
        const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
        const parent = Array.from({ length: rows }, () => Array(cols).fill(null));

        queue.push({ x: startX, y: startY });
        visited[startY][startX] = true;

        while (queue.length) {
            const { x, y } = queue.shift();
            if (x === targetX && y === targetY) {
                const path = [];
                let curX = x;
                let curY = y;
                while (curX !== startX || curY !== startY) {
                    path.unshift({ x: curX, y: curY });
                    const p = parent[curY][curX];
                    curX = p.x;
                    curY = p.y;
                }
                path.unshift({ x: startX, y: startY });
                return path;
            }

            const neighbors = [
                { x: x + 1, y },
                { x: x - 1, y },
                { x, y: y + 1 },
                { x, y: y - 1 }
            ];

            for (const n of neighbors) {
                if (n.x >= 0 && n.x < cols && n.y >= 0 && n.y < rows && !visited[n.y][n.x]) {
                    if (map[n.y][n.x] !== '#') {
                        queue.push(n);
                        visited[n.y][n.x] = true;
                        parent[n.y][n.x] = { x, y };
                    }
                }
            }
        }
        return null;
    }

    function canMove(x, y) {
        if (x < 0 || x >= cols || y < 0 || y >= rows) return false;
        if (map[y][x] === '#') return false;
        return true;
    }

    function updatePacman() {
        if (deathAnimation) return;
        if (canMove(pacman.x + pacman.nextDx, pacman.y + pacman.nextDy)) {
            pacman.dx = pacman.nextDx;
            pacman.dy = pacman.nextDy;
        }
        if (canMove(pacman.x + pacman.dx, pacman.y + pacman.dy)) {
            pacman.x += pacman.dx;
            pacman.y += pacman.dy;
        }
    }

    function drawPacman() {
        if (deathAnimation) {
            const px = pacman.x * tileSize + tileSize / 2;
            const py = pacman.y * tileSize + tileSize / 2;
            ctx.fillStyle = `rgba(255, 235, 59, ${1 - deathProgress})`;
            ctx.beginPath();
            ctx.arc(px, py, pacman.radius * (1 - deathProgress), 0, Math.PI * 2);
            ctx.fill();
            return;
        }

        const px = pacman.x * tileSize + tileSize / 2;
        const py = pacman.y * tileSize + tileSize / 2;
        const openMouth = 0.25 + 0.25 * pacman.mouthOpen;

        ctx.fillStyle = "#FFEB3B";
        ctx.beginPath();

        let angle1, angle2;
        if (pacman.dx === 1) {
            angle1 = (openMouth * Math.PI * 2) / 3;
            angle2 = (2 * Math.PI) - angle1;
        } else if (pacman.dx === -1) {
            angle1 = Math.PI - (openMouth * Math.PI * 2) / 3;
            angle2 = Math.PI + (openMouth * Math.PI * 2) / 3;
        } else if (pacman.dy === 1) {
            angle1 = Math.PI / 2 - (openMouth * Math.PI * 2) / 3;
            angle2 = Math.PI / 2 + (openMouth * Math.PI * 2) / 3;
        } else if (pacman.dy === -1) {
            angle1 = (3 * Math.PI) / 2 - (openMouth * Math.PI * 2) / 3;
            angle2 = (3 * Math.PI) / 2 + (openMouth * Math.PI * 2) / 3;
        } else {
            angle1 = openMouth * Math.PI;
            angle2 = 2 * Math.PI - openMouth * Math.PI;
        }

        ctx.moveTo(px, py);
        ctx.arc(px, py, pacman.radius, angle1, angle2, false);
        ctx.closePath();
        ctx.fill();
        ctx.shadowColor = '#FFEB3B';
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;

        pacman.mouthOpen += pacman.mouthDir * 0.1;
        if (pacman.mouthOpen > 1 || pacman.mouthOpen < 0) {
            pacman.mouthDir *= -1;
        }
    }

    function eatDots() {
        if (map[pacman.y][pacman.x] === '.') {
            map[pacman.y][pacman.x] = ' ';
            score += 10;
            playSound(440, 100);
            spawnParticles(pacman.x, pacman.y, 5, '#FFEB3B');
        }
        if (map[pacman.y][pacman.x] === 'G') {
            map[pacman.y][pacman.x] = ' ';
            score += 50;
            playSound(660, 150);
            spawnParticles(pacman.x, pacman.y, 10, '#ff0055');
            ghosts.forEach(g => {
                g.frightened = true;
                g.frightenedCounter = 300;
            });
        }
    }

    function checkCollisions() {
        for (const ghost of ghosts) {
            if (ghost.x === pacman.x && ghost.y === pacman.y) {
                if (ghost.frightened) {
                    score += 200;
                    playSound(880, 200);
                    ghost.x = 13;
                    ghost.y = 11;
                    ghost.frightened = false;
                    ghost.frightenedCounter = 0;
                    spawnParticles(ghost.x, ghost.y, 8, ghost.color);
                } else {
                    deathAnimation = true;
                    playSound(110, 500);
                }
            }
        }
    }

    function update() {
        if (gameOver) return;
        if (deathAnimation) {
            deathProgress += 0.02;
            if (deathProgress >= 1) {
                deathAnimation = false;
                deathProgress = 0;
                gameOver = true;
                gameOverDiv.style.display = "flex";
                finalScore.textContent = score;
            }
            draw();
            return;
        }
        updatePacman();
        eatDots();
        ghosts.forEach(g => g.move());
        checkCollisions();
        updateParticles();
        draw();
    }

    function draw() {
        drawMap();
        drawParticles();
        drawPacman();
        ghosts.forEach(g => g.draw());
        scoreboard.textContent = `Pontos: ${score}`;
    }

    function resetGame() {
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (mapData[y][x] === '.') map[y][x] = '.';
                else if (mapData[y][x] === 'G') map[y][x] = 'G';
                else map[y][x] = mapData[y][x];
            }
        }
        pacman.x = 13;
        pacman.y = 23;
        pacman.dx = 0;
        pacman.dy = 0;
        pacman.nextDx = 0;
        pacman.nextDy = 0;
        score = 0;
        gameOver = false;
        deathAnimation = false;
        deathProgress = 0;
        gameOverDiv.style.display = "none";

        ghosts[0].x = 13; ghosts[0].y = 11; ghosts[0].frightened = false; ghosts[0].frightenedCounter = 0;
        ghosts[1].x = 14; ghosts[1].y = 11; ghosts[1].frightened = false; ghosts[1].frightenedCounter = 0;
        ghosts[2].x = 12; ghosts[2].y = 11; ghosts[2].frightened = false; ghosts[2].frightenedCounter = 0;
        ghosts[3].x = 15; ghosts[3].y = 11; ghosts[3].frightened = false; ghosts[3].frightenedCounter = 0;

        draw();
    }

    window.addEventListener("keydown", e => {
        switch (e.key) {
            case "ArrowUp":
                pacman.nextDx = 0;
                pacman.nextDy = -1;
                break;
            case "ArrowDown":
                pacman.nextDx = 0;
                pacman.nextDy = 1;
                break;
            case "ArrowLeft":
                pacman.nextDx = -1;
                pacman.nextDy = 0;
                break;
            case "ArrowRight":
                pacman.nextDx = 1;
                pacman.nextDy = 0;
                break;
            case "r":
            case "R":
                if (gameOver) resetGame();
                break;
        }
    });

    restartButton.addEventListener("click", () => {
        if (gameOver) resetGame();
    });

    function gameLoop() {
        update();
        requestAnimationFrame(gameLoop);
    }

    resetGame();
    gameLoop();
})();
</script>
</body>
</html>